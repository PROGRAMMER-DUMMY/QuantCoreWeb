import os
import sys
import json
import time
from datetime import datetime, timedelta
from os import WCONTINUED

from security.auth import render_login
import streamlit as st
import pandas as pd
import polars as pl
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
from streamlit_option_menu import option_menu

# Remove pyprojroot if not strictly needed, or ensure it's installed
# from pyprojroot import here

# if not render_login():
#         st.stop()


# ==========================================
# 1. SYSTEM PATH CONFIGURATION
# ==========================================
# Assuming this script runs from project root
sys.path.append(os.getcwd())

# ==========================================
# 2. STREAMLIT PAGE SETUP
# ==========================================
st.set_page_config(
    page_title="QuantCore Terminal",
    layout="wide",
    initial_sidebar_state="expanded",
    page_icon="ðŸ’ "
)

# Attempt Imports
try:
    from config.config import PATHS, EXECUTION, CRYPTO
except ImportError:
    st.error("Configuration Error: Ensure you are running this from the project root and 'config/' exists.")
    st.stop()

# ==========================================
# 3. UI STYLING (Clean Fintech Theme)
# ==========================================
st.markdown("""
<style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');

    .stApp { background-color: #f8f9fa; color: #1a202c; font-family: 'Inter', sans-serif; }

    /* Metrics Cards */
    div[data-testid="stMetric"] {
        background-color: #ffffff; border: 1px solid #e2e8f0;
        border-radius: 8px; padding: 16px; box-shadow: 0 1px 2px rgba(0,0,0,0.05);
    }
    div[data-testid="stMetricValue"] { font-size: 1.5rem !important; font-weight: 700; color: #2d3748; }

    /* Sidebar */
    section[data-testid="stSidebar"] { background-color: #ffffff; border-right: 1px solid #e2e8f0; }

    /* Custom Log Terminal */
    .log-container {
        background-color: #1e1e1e; color: #d4d4d4; font-family: 'Courier New', monospace;
        padding: 15px; border-radius: 8px; height: 500px; overflow-y: scroll;
        border: 1px solid #333; font-size: 12px; line-height: 1.5;
    }
    .log-info { color: #4ec9b0; }
    .log-warn { color: #ce9178; }
    .log-error { color: #f44747; font-weight: bold; }
    .log-time { color: #569cd6; margin-right: 10px; }

    /* AI Signal Badge */
    .ai-bull { color: #22c55e; font-weight: bold; background: #dcfce7; padding: 2px 8px; border-radius: 4px; }
    .ai-bear { color: #ef4444; font-weight: bold; background: #fee2e2; padding: 2px 8px; border-radius: 4px; }
</style>
""", unsafe_allow_html=True)


# ==========================================
# 4. DATA LOADERS
# ==========================================
def load_bot_status():
    """Reads the JSON status file generated by main_live.py"""
    try:
        path = os.path.join(PATHS.data_dir, "bot_status.json")
        if os.path.exists(path):
            with open(path, 'r') as f: return json.load(f)
    except:
        pass
    return None


@st.cache_data
def load_registry():
    try:
        path = os.path.join(PATHS.base_dir, 'registry', 'index.json')
        if os.path.exists(path):
            with open(path, 'r') as f: return json.load(f)
    except:
        pass
    return {}


@st.cache_data
def load_market_data(symbol, timeframe="15m", start_date=None, end_date=None, limit=None):
    try:
        safe_sym = symbol.replace('/', '-')
        path = os.path.join(PATHS.data_dir, safe_sym, f"{timeframe}.parquet")
        if os.path.exists(path):
            lf = pl.scan_parquet(path)
            if start_date:
                s_ts = int((start_date - timedelta(days=2)).timestamp() * 1000)
                lf = lf.filter(pl.col("timestamp") >= s_ts)
            if end_date:
                e_ts = int((end_date + timedelta(days=1)).timestamp() * 1000)
                lf = lf.filter(pl.col("timestamp") <= e_ts)
            if not start_date and not end_date and limit:
                df = lf.tail(limit).collect().to_pandas()
            else:
                df = lf.collect().to_pandas()
            df['timestamp'] = pd.to_datetime(df['timestamp'], unit='ms')
            return df
    except:
        pass
    return pd.DataFrame()


@st.cache_data
def load_trade_history(bot_path):
    # Load from registry bot path, check both simulation and live files
    for fname in ["live_trades.csv", "trades.csv"]:
        fpath = os.path.join(bot_path, fname)
        if os.path.exists(fpath):
            try:
                # Use pandas for easier parsing of inconsistent CSVs, then convert if needed
                df = pd.read_csv(fpath)
                if df.empty: continue

                # Convert dates
                if "Entry_Date" in df.columns: df["Entry_Date"] = pd.to_datetime(df["Entry_Date"])
                if "Exit_Date" in df.columns: df["Exit_Date"] = pd.to_datetime(df["Exit_Date"])

                # Convert to Polars for analytics engine
                pl_df = pl.from_pandas(df)

                # Add analytics columns
                pl_df = pl_df.with_columns(pl.col("PnL_USD").cum_sum().alias("Cum_PnL"))
                pl_df = pl_df.with_columns(pl.col("Cum_PnL").cum_max().alias("HWM"))
                pl_df = pl_df.with_columns((pl.col("Cum_PnL") - pl.col("HWM")).alias("Drawdown_USD"))

                return pl_df
            except Exception as e:
                print(f"Error loading {fname}: {e}")
    return pl.DataFrame()


# ==========================================
# 5. ANALYTICS ENGINE
# ==========================================
class AnalyticsEngine:
    @staticmethod
    def generate_charts(df: pl.DataFrame):
        pdf = df.to_pandas()
        pdf['Year'] = pdf['Exit_Date'].dt.year
        pdf['Month'] = pdf['Exit_Date'].dt.month
        pdf['Month_Label'] = pdf['Exit_Date'].dt.strftime('%Y-%m')

        # 1. Equity & Drawdown
        fig_eq = make_subplots(specs=[[{"secondary_y": True}]])
        fig_eq.add_trace(go.Scatter(x=pdf['Exit_Date'], y=pdf['Cum_PnL'], name="Equity",
                                    line=dict(color='#3182ce', width=2), fill='tozeroy'), secondary_y=False)
        fig_eq.add_trace(go.Scatter(x=pdf['Exit_Date'], y=pdf['Drawdown_USD'], name="Drawdown",
                                    line=dict(color='#e53e3e', width=1), fill='tozeroy'), secondary_y=True)
        fig_eq.update_layout(title="<b>Account Growth</b>", template="plotly_white", height=380, hovermode="x unified")

        # 2. Monthly Gross vs Net
        monthly_grouped = pdf.groupby('Month_Label').apply(lambda x: pd.Series({
            'Gross_Profit': x[x['PnL_USD'] > 0]['PnL_USD'].sum(),
            'Gross_Loss': x[x['PnL_USD'] < 0]['PnL_USD'].sum(),
            'Net_PnL': x['PnL_USD'].sum()
        })).reset_index()

        fig_monthly = go.Figure()
        fig_monthly.add_trace(
            go.Bar(x=monthly_grouped['Month_Label'], y=monthly_grouped['Gross_Profit'], name='Gross Profit',
                   marker_color='#48bb78'))
        fig_monthly.add_trace(
            go.Bar(x=monthly_grouped['Month_Label'], y=monthly_grouped['Gross_Loss'], name='Gross Loss',
                   marker_color='#f56565'))
        fig_monthly.add_trace(go.Scatter(x=monthly_grouped['Month_Label'], y=monthly_grouped['Net_PnL'], name='Net PnL',
                                         line=dict(color='#1a202c', width=2, dash='dot')))
        fig_monthly.update_layout(title="<b>Monthly PnL Breakdown</b>", barmode='relative', template="plotly_white",
                                  height=380)

        # 3. Monthly Heatmap
        heat_data = pdf.groupby(['Year', 'Month'])['PnL_USD'].sum().unstack(fill_value=0)
        fig_heat = go.Figure(data=go.Heatmap(
            z=heat_data.values, x=heat_data.columns, y=heat_data.index,
            colorscale='RdYlGn', text=heat_data.values.round(0), texttemplate="$%{text}", xgap=2, ygap=2
        ))
        fig_heat.update_layout(title="<b>Return Heatmap</b>", template="plotly_white", height=380)

        # 4. Asset Stacked Bar
        asset_monthly = pdf.groupby(['Month_Label', 'Asset'])['PnL_USD'].sum().reset_index()
        fig_asset_stack = px.bar(asset_monthly, x="Month_Label", y="PnL_USD", color="Asset",
                                 title="<b>Asset PnL Contribution per Month</b>", template="plotly_white")
        fig_asset_stack.update_layout(height=450, barmode='relative')

        # 5. Asset Matrix
        asset_month_matrix = pdf.pivot_table(index='Asset', columns='Month_Label', values='PnL_USD',
                                             aggfunc='sum').fillna(0)
        fig_matrix = go.Figure(data=go.Heatmap(
            z=asset_month_matrix.values, x=asset_month_matrix.columns, y=asset_month_matrix.index,
            colorscale='RdBu', text=asset_month_matrix.values.round(0), texttemplate="$%{text}", xgap=1, ygap=1
        ))
        fig_matrix.update_layout(title="<b>Asset Monthly Performance Matrix</b>", template="plotly_white", height=450)

        # 6. Strategy Stats
        strat_stats = pdf.groupby("Reason")['PnL_USD'].sum().reset_index().sort_values("PnL_USD")
        fig_strat = px.bar(strat_stats, x="PnL_USD", y="Reason", orientation='h', title="<b>Strategy Performance</b>",
                           color="PnL_USD", color_continuous_scale="RdYlGn", template="plotly_white")
        fig_strat.update_layout(height=350)

        return fig_eq, fig_monthly, fig_heat, fig_asset_stack, fig_matrix, fig_strat


# ==========================================
# 6. MAIN APPLICATION LOGIC
# ==========================================

with st.sidebar:
    st.markdown("## ðŸ’  QuantCore")
    st.caption("Environment: **Production**")

    menu = option_menu(
        "Menu", ["Live Terminal", "Analytics", "Visualizer", "Logs"],
        icons=['activity', 'bar-chart-fill', 'eye', 'terminal'],
        menu_icon="cast", default_index=0,
        styles={"container": {"padding": "0!important", "background-color": "#ffffff"},
                "icon": {"color": "#3182ce", "font-size": "14px"},
                "nav-link": {"font-size": "14px", "text-align": "left", "margin": "0px", "--hover-color": "#f1f5f9"},
                "nav-link-selected": {"background-color": "#3182ce"}}
    )

    st.markdown("---")
    # Live Status Indicator
    try:
        path = os.path.join(PATHS.data_dir, "bot_status.json")
        if os.path.exists(path):
            mtime = os.path.getmtime(path)
            lag = time.time() - mtime
            status_text = "Online" if lag < 30 else "Stalled"
            color = "green" if lag < 30 else "red"
            st.markdown(f"**Bot Status**: :{color}[{status_text}] ({int(lag)}s ago)")
    except:
        st.markdown("**Bot Status**: :grey[Unknown]")

# --- PAGE 1: LIVE TERMINAL ---
if menu == "Live Terminal":
    st.title("Live Terminal")

    # Auto-Refresh for Live Data
    if st.checkbox("Auto-Refresh (5s)", value=True):
        time.sleep(5)
        st.rerun()

    status_data = load_bot_status()

    # 1. Top Metrics
    c1, c2, c3, c4 = st.columns(4)
    if status_data:
        c1.metric("Status", status_data.get("status", "Unknown"))
        c2.metric("Last Update", status_data.get("last_update", "N/A"))
        c3.metric("Active Models", status_data.get("active_models", 0))
        # Placeholder for Wallet Balance if we had it in status.json, else N/A
        c4.metric("Mode", EXECUTION.mode)
    else:
        st.warning("No live bot status found. Ensure 'main_live.py' is running.")

    col_main, col_side = st.columns([2, 1])

    # 2. AI Brain (Right Column)
    with col_side:
        st.subheader("ðŸ§  AI Signals")
        if status_data and "latest_signals" in status_data:
            signals = status_data["latest_signals"]
            sig_df = pd.DataFrame(list(signals.items()), columns=["Symbol", "Signal"])


            # Formatting function for badges
            def format_signal(val):
                if "Bull" in val or "EXECUTED" in val:
                    return f'<span class="ai-bull">{val}</span>'
                else:
                    return f'<span class="ai-bear">{val}</span>'


            sig_df["Signal"] = sig_df["Signal"].apply(format_signal)
            st.write(sig_df.to_html(escape=False, index=False), unsafe_allow_html=True)
        else:
            st.info("No active signals.")

    # 3. Live Trades (Main Column)
    with col_main:
        st.subheader("RECENT TRADES")
        # Load live_trades.csv from current bot folder (Need to find latest bot path first)
        reg = load_registry()
        if reg:
            # Sort keys to find latest
            latest_id = sorted(reg.keys())[-1]
            bot_path = reg[latest_id]['path']
            live_trades_path = os.path.join(bot_path, "live_trades.csv")

            if os.path.exists(live_trades_path):
                lt_df = pd.read_csv(live_trades_path)
                st.dataframe(
                    lt_df.sort_values("Time", ascending=False).head(10),
                    use_container_width=True, hide_index=True
                )
            else:
                st.info("No live trades executed yet.")
        else:
            st.error("Registry empty.")

# --- PAGE 2: FULL ANALYTICS ---
elif menu == "Analytics":
    st.title("Strategy Analytics")
    reg = load_registry()
    if not reg: st.stop()

    c1, c2 = st.columns([3, 1])
    with c1:
        # Sort by creation date
        sorted_bots = sorted(reg.keys(), reverse=True)
        bot_id = st.selectbox("Select Strategy", sorted_bots)

    pl_df = load_trade_history(reg[bot_id]['path'])

    if not pl_df.is_empty():
        # Global Filter
        all_assets = ["All"] + sorted(pl_df["Asset"].unique().to_list())
        with c2:
            filter_asset = st.selectbox("Filter Asset", all_assets)

        filtered_df = pl_df if filter_asset == "All" else pl_df.filter(pl.col("Asset") == filter_asset)

        if not filtered_df.is_empty():
            # Calculate Executive Summary Stats
            gross_profit = filtered_df.filter(pl.col("PnL_USD") > 0)["PnL_USD"].sum()
            gross_loss = filtered_df.filter(pl.col("PnL_USD") < 0)["PnL_USD"].sum()
            pf = (gross_profit / abs(gross_loss)) if gross_loss != 0 else 0
            win_rate = (filtered_df.filter(pl.col("PnL_USD") > 0).height / filtered_df.height) * 100

            m1, m2, m3, m4 = st.columns(4)
            m1.metric("Net Profit", f"${filtered_df['PnL_USD'].sum():,.2f}")
            m2.metric("Win Rate", f"{win_rate:.2f}%")
            m3.metric("Profit Factor", f"{pf:.2f}")
            m4.metric("Avg Trade", f"${filtered_df['PnL_USD'].mean():.2f}")

            # Generate Charts
            fig_eq, fig_monthly, fig_heat, fig_stack, fig_matrix, fig_strat = AnalyticsEngine.generate_charts(
                filtered_df)

            # Layout
            st.plotly_chart(fig_eq, use_container_width=True)

            c1, c2 = st.columns(2)
            with c1:
                st.plotly_chart(fig_monthly, use_container_width=True)
            with c2:
                st.plotly_chart(fig_heat, use_container_width=True)

            st.plotly_chart(fig_stack, use_container_width=True)
            st.plotly_chart(fig_matrix, use_container_width=True)
            st.plotly_chart(fig_strat, use_container_width=True)

            # --- STATISTICAL BREAKDOWN ---
            st.markdown("### Statistical Breakdown")
            t1, t2, t3, t4 = st.tabs(["By Asset", "Long/Short", "Duration", "Raw Data"])

            with t1:
                st.dataframe(filtered_df.group_by("Asset").agg([
                    pl.len().alias("Trades"),
                    pl.col("PnL_USD").sum().round(2).alias("Total PnL"),
                    pl.col("PnL_USD").mean().round(2).alias("Avg PnL"),
                    (pl.col("PnL_USD").filter(pl.col("PnL_USD") > 0).len() / pl.len() * 100).round(1).alias("Win %")
                ]).sort("Total PnL", descending=True).to_pandas(), use_container_width=True, hide_index=True)

            with t2:
                # Assuming 'Type' column exists (Long/Short) - from main.py logic it should be 'Type'
                # If using simulation.py output, it might be 1/-1, ensure simulation saves string 'Long'/'Short'
                if "Type" in filtered_df.columns:
                    st.dataframe(filtered_df.group_by("Type").agg([
                        pl.len().alias("Trades"),
                        pl.col("PnL_USD").sum().round(2).alias("Total PnL"),
                        (pl.col("PnL_USD").filter(pl.col("PnL_USD") > 0).len() / pl.len() * 100).round(1).alias("Win %")
                    ]).to_pandas(), use_container_width=True, hide_index=True)

            with t3:
                dur_df = filtered_df.with_columns((pl.col("Exit_Date") - pl.col("Entry_Date")).alias("Duration"))
                # Polars duration to string/float might be needed for display
                st.dataframe(dur_df.select(["Asset", "Type", "Entry_Date", "Exit_Date", "Duration", "PnL_USD"]).head(
                    50).to_pandas(), use_container_width=True)

            with t4:
                st.dataframe(filtered_df.to_pandas(), use_container_width=True)

        else:
            st.info(f"No trades found for {filter_asset}")
    else:
        st.warning("No trade history found for this strategy.")

# --- PAGE 3: VISUALIZER ---
elif menu == "Visualizer":
    st.title("Trade Inspector")
    reg = load_registry()
    c1, c2 = st.columns(2)
    with c1:
        bot_id = st.selectbox("1. Strategy", sorted(list(reg.keys()), reverse=True))

    pl_df = load_trade_history(reg[bot_id]['path'])

    if not pl_df.is_empty():
        assets = pl_df["Asset"].unique().to_list()
        with c2:
            symbol = st.selectbox("2. Asset", assets)

        asset_trades = pl_df.filter(pl.col("Asset") == symbol).sort("Entry_Date", descending=True).to_pandas()

        # Create a label for the dropdown
        asset_trades['Label'] = asset_trades.apply(
            lambda x: f"{x['Entry_Date'].strftime('%Y-%m-%d %H:%M')} | {x.get('Type', 'Trade')} | ${x['PnL_USD']:.2f}",
            axis=1
        )

        trade_options = ["Overview (Recent)"] + asset_trades['Label'].tolist()
        selected_view = st.selectbox("3. Select View", trade_options)

        # Logic to fetch market data based on view
        if "Overview" in selected_view:
            # Load recent 1000 candles
            df_candles = load_market_data(symbol, limit=1000)
            plot_trades = asset_trades
            title_text = f"{symbol} - Recent Overview"
        else:
            trade_row = asset_trades[asset_trades['Label'] == selected_view].iloc[0]
            # Context: 2 days before, 1 day after
            start_dt = trade_row['Entry_Date'] - timedelta(days=2)
            end_dt = trade_row['Exit_Date'] + timedelta(days=1)

            df_candles = load_market_data(symbol, start_date=start_dt, end_date=end_dt)
            plot_trades = asset_trades[asset_trades['Label'] == selected_view]
            title_text = f"{symbol} Trade Focus"

        if not df_candles.empty:
            # Plotly Chart
            fig = make_subplots(rows=2, cols=1, shared_xaxes=True, vertical_spacing=0.03,
                                subplot_titles=(title_text, 'Volume'), row_width=[0.2, 0.7])

            # Candlestick
            fig.add_trace(go.Candlestick(x=df_candles['timestamp'], open=df_candles['open'],
                                         high=df_candles['high'], low=df_candles['low'], close=df_candles['close'],
                                         name='Price'), row=1, col=1)

            # Volume
            colors = ['#10b981' if c >= o else '#ef4444' for c, o in zip(df_candles['close'], df_candles['open'])]
            fig.add_trace(go.Bar(x=df_candles['timestamp'], y=df_candles['volume'], marker_color=colors, name='Volume'),
                          row=2, col=1)

            # Trade Markers
            if not plot_trades.empty:
                # Ensure required columns exist to avoid KeyError
                required_cols = ['Entry_Date', 'Entry_Price', 'Exit_Date', 'Exit_Price']
                if all(col in plot_trades.columns for col in required_cols):

                    # Draw Entries
                    if 'Type' in plot_trades.columns:
                        # Longs
                        buys = plot_trades[plot_trades['Type'] == 'Long']
                        if not buys.empty:
                            fig.add_trace(go.Scatter(
                                x=buys['Entry_Date'], y=buys['Entry_Price'], mode='markers',
                                marker=dict(symbol='triangle-up', size=14, color='#2962ff'), name='Buy Long'
                            ), row=1, col=1)

                        # Shorts
                        sells = plot_trades[plot_trades['Type'] == 'Short']
                        if not sells.empty:
                            fig.add_trace(go.Scatter(
                                x=sells['Entry_Date'], y=sells['Entry_Price'], mode='markers',
                                marker=dict(symbol='triangle-down', size=14, color='#d50000'), name='Sell Short'
                            ), row=1, col=1)
                    else:
                        # Fallback for untyped trades
                        fig.add_trace(go.Scatter(
                            x=plot_trades['Entry_Date'], y=plot_trades['Entry_Price'], mode='markers',
                            marker=dict(symbol='circle', size=12, color='blue'), name='Entry'
                        ), row=1, col=1)

                    # Draw Exits (Universal)
                    fig.add_trace(go.Scatter(
                        x=plot_trades['Exit_Date'], y=plot_trades['Exit_Price'], mode='markers',
                        marker=dict(symbol='x', size=10, color='black'), name='Exit'
                    ), row=1, col=1)

            fig.update_layout(height=700, xaxis_rangeslider_visible=False, template="plotly_white",
                              hovermode="x unified")
            st.plotly_chart(fig, use_container_width=True)

        else:
            st.warning(
                f"No market data found for {symbol} in the selected period. Ensure 'downloader.py' has been run.")
    else:
        st.info("No trades to visualize.")

# --- PAGE 4: LOGS ---
elif menu == "Logs":
    st.title("System Logs")

    # 1. Select Log
    log_options = ["live_trading.log", "master_run.log", "downloader.log"]
    fname = st.selectbox("Log File", log_options)
    path = os.path.join(PATHS.logs_dir, fname)

    st.markdown('<div class="log-container">', unsafe_allow_html=True)
    if os.path.exists(path):
        with open(path, 'r') as f:
            # Read last 300 lines
            lines = f.readlines()[-300:]
            for line in lines:
                cls = "log-info"
                if "WARNING" in line:
                    cls = "log-warn"
                elif "ERROR" in line or "CRITICAL" in line:
                    cls = "log-error"

                # Simple formatting
                clean_line = line.strip()
                st.markdown(f'<div class="{cls}">{clean_line}</div>', unsafe_allow_html=True)
    else:
        st.markdown("<div>No logs found.</div>", unsafe_allow_html=True)
    st.markdown('</div>', unsafe_allow_html=True)